---
layout:     post
title:      深度学习
subtitle:   基于Python的研究和实现
date:       2026-02-09
author:     LXG
header-img: img/post-bg-digital_circuits.jpg
catalog: true
tags:
    - AI
    - 职业
---

## 查看系统中的python版本

```bash

lxg@lxg:~/code$ ls -al /usr/bin/python*
lrwxrwxrwx 1 root root      16  6月  3  2025 /usr/bin/python -> /usr/bin/python2
lrwxrwxrwx 1 root root       9  7月 28  2021 /usr/bin/python2 -> python2.7
-rwxr-xr-x 1 root root 3592536 12月 10  2024 /usr/bin/python2.7
lrwxrwxrwx 1 root root      10 11月 26  2024 /usr/bin/python3 -> python3.10
-rwxr-xr-x 1 root root 5937672  1月  8 14:52 /usr/bin/python3.10

```

## NumPy

numpy 是 Python 里最重要的科学计算库之一，主要用来：

* 数组运算（比 list 快很多）
* 矩阵计算
* 数学运算（线性代数、随机数等）
* 深度学习底层计算（PyTorch、TensorFlow 都依赖它）

```py

# 导入 Python 的 numpy 库，并把它起一个简写名字 np 使用
import numpy as np

def main():
    # Create a 3x3 array of random floats between 0 and 1
    array = np.random.rand(3, 3)
    
    # Print the array
    print("3x3 Array of Random Floats:")
    print(array)


if __name__ == "__main__":
    main()

```

NumPy 数组可以生成N维数组，数学上将一维数组称为**向量**， 二维数组称为**矩阵**，多维数组称为**张量**

| 名称     | 维度  | 例子            |
| ------ | --- | ------------- |
| **标量** | 0维  | 5             |
| **向量** | 1维  | [1,2,3]       |
| **矩阵** | 2维  | [[1,2],[3,4]]   比如：表格 |
| **张量** | ≥3维 | 多维数组    比如：图片、视频、batch   |

**广播**不同维度数组之间的计算

## Python VS C++

| 项    | Python    | C++       |
| ---- | --------- | --------- |
| 类型   | 解释型       | 编译型       |
| 语法   | 简单        | 复杂        |
| 开发效率 | 非常高       | 较低        |
| 执行速度 | 慢         | 非常快       |
| 内存控制 | 自动        | 手动        |
| 学习成本 | 低         | 高         |
| 适合人群 | 数据/AI/自动化 | 系统/性能/嵌入式 |

**C++ 速度 = Python 的 10~100 倍**

## Matplotlib

Matplotlib 是 Python 最常用的数据可视化库，用来画图

| 函数            | 作用   |
| ------------- | ---- |
| plt.plot()    | 折线图  |
| plt.scatter() | 散点图  |
| plt.bar()     | 柱状图  |
| plt.imshow()  | 显示图像 |
| plt.title()   | 标题   |
| plt.xlabel()  | x轴   |
| plt.ylabel()  | y轴   |
| plt.legend()  | 图例   |
| plt.show()    | 显示图  |

```python

import numpy as np

import matplotlib.pyplot as plt

# 生成数据
x = np.arange(0, 6, 0.1)
y = np.sin(x)

# 创建图形
plt.plot(x, y)
plt.title("Sine Wave")
plt.xlabel("X Axis")
plt.ylabel("Y Axis")
plt.show()

```

**运行后生成图形**

![python_matplotlib](/images/ai/python_matplotlib.png)

## 显示图像

```py

import numpy as np

import matplotlib.pyplot as plt

from matplotlib.image import imread

img= imread('car.jpg')
plt.imshow(img)

plt.show()

```

**运行后显示结果**

![python_matplotlib_image](/images/ai/python_matplotlib_image.png)

## 感知机

感知机就是一个“会加权判断的神经元”，深度学习的所有复杂神经网络都是由无数个感知机堆起来的

**感知机的数学公式**

```markdown

y=f(w1​x1​+w2​x2​+...+wn​xn​+b)

```

| 符号              | 含义                          |
| --------------- | --------------------------- |
| x1, x2, ..., xn | 输入特征                        |
| w1, w2, ..., wn | 权重（代表每个特征的重要性）              |
| b               | 偏置（可以调整阈值）                  |
| f()             | 激活函数，通常是阶跃函数（大于0就输出1，否则输出0） |
| y               | 输出（1 或 0）                   |

权重相当于电流中的电阻， 电阻是决定电流流动难度的参数，电阻越低通过的电流越大。感知机则是权重越大，通过的信号就越大

### 简单逻辑电路

| x1 | x2 | y |
| -- | -- | - |
| 0  | 0  | 0 |
| 0  | 1  | 0 |
| 1  | 0  | 0 |
| 1  | 1  | 1 |

**感知机公式**

```markdown

y=f(w1​x1​+w2​x2​+b)

```

| 逻辑门 | 权重 w1 w2  | 偏置 b |
| --- | ----- | ---- |
| AND | [1,1] | -1.5 |
| OR  | [1,1] | -0.5 |
| NOT | [-1]  | 0.5  |


表示 AND 门 并不只有一组权重和偏置，它有 无限组等价解，只要满足条件就行

**训练就是在无数可能解中找到一组合适的 w 和 b，让训练数据分类正确**

**机器学习是确定合适的参数的过程，人要做的是思考感知机的构造，并把训练数据交给计算机**

### 开源大模型开源的是什么

| 部分                     | 内容                                 | 是否通常开源                         |
| ---------------------- | ---------------------------------- | ------------------------------ |
| **模型权重（Weights）**      | 训练好的参数（神经网络里所有 w/b）                | ✅ 有些开源（如 LLaMA 2、MPT、Falcon 等） |
| **模型架构（Architecture）** | Transformer 层数、注意力机制、激活函数、网络拓扑     | ✅ 通常开源（论文 + 代码）                |
| **训练算法 / 数据 /训练框架**    | 优化器（Adam、LoRA）、训练策略、训练数据、并行技巧、混合精度 | ❌ 通常不开源或部分开源                   |

**DeepSeek开源程度**

| 项目              | 权重是否开源   | 架构/代码是否开源   | 训练数据/算法是否开源    |
| --------------- | -------- | ----------- | -------------- |
| **Qwen 系列**     | ✅ 多版本权重  | ✅ 推理 + 架构代码 | 部分或未完全开源       |
| **DeepSeek 系列** | ❗ 部分权重开源 | ✅ 部分基础代码    | ❌ 多数训练数据与细节不开源 |

### 垂直领域大模型的训练方法

* 利用 通用大模型的预训练知识（语言、视觉、常识）
* 再用垂直领域数据进行微调，让模型在专业领域表现更好

```markdown

通用大模型（预训练）：
   ┌───────────┐
   │语言/视觉/常识│
   └───────────┘
           │
           ▼ 微调 / LoRA / 指令调优
垂直领域大模型（专业知识）：
   ┌─────────────┐
   │医疗/法律/工业│
   └─────────────┘

```

**Anthropic 垂直模型是怎样训练的**

```markdown

           ┌───────────────────────────────┐
           │ 1️⃣ 通用大模型（开源/预训练） │
           │ - 已学通用语言/知识            │
           │ - 可直接推理                   │
           └─────────────┬─────────────────┘
                         │
                         ▼
           ┌───────────────────────────────┐
           │ 2️⃣ 数据收集与标注              │
           │ - 企业内部文档、FAQ、对话      │
           │ - 高质量标注：问题 → 答案      │
           │ ⚠ 数据成本高                   │
           └─────────────┬─────────────────┘
                         │
                         ▼
           ┌───────────────────────────────┐
           │ 3️⃣ 微调/定制训练               │
           │ - 全量微调：成本高，效果佳      │
           │ - LoRA/Adapter：小数据低成本    │
           │ - 调整权重适应行业任务          │
           │ ⚠ 算力成本高                   │
           └─────────────┬─────────────────┘
                         │
                         ▼
           ┌───────────────────────────────┐
           │ 4️⃣ 模型评估与优化               │
           │ - 验证准确率、召回率、延迟       │
           │ - 推理优化：量化/剪枝/多卡并行 │
           │ ⚠ 工程/硬件成本                 │
           └─────────────┬─────────────────┘
                         │
                         ▼
           ┌───────────────────────────────┐
           │ 5️⃣ 部署与监控                   │
           │ - 企业服务器或云端部署           │
           │ - 实时监控模型性能               │
           │ - 数据更新 → 定期微调            │
           │ ⚠ 人才与维护成本                │
           └───────────────────────────────┘

```

![vertical_model_training](/images/ai/vertical_model_training.png)

### OCR 和 LLM 图像识别的差异

| 特性   | OCR                 | LLM 图像识别/多模态模型 |
| ---- | ------------------- | -------------- |
| 主要任务 | 文字识别                | 图像理解 + 语言生成    |
| 输入   | 图像                  | 图像 + 可选文本提示    |
| 输出   | 文本（字符级）             | 文本（句子/回答）      |
| 精度关注 | 字符级精度               | 场景理解和语言表达      |
| 技术   | CNN/RNN/Transformer | 图像编码器 + LLM    |
| 应用场景 | 扫描文档、票据、证件          | 图像问答、图像描述、视觉推理 |

**OCR VS LLM 训练流程**

```markdown

OCR                       LLM
------                     -----
手工标注图片 ──► 训练集       原始文本/图像 ──► 自动生成训练任务
        │                         │
        ▼                         ▼
     OCR 模型                 LLM 模型
        │                         │
        ▼                         ▼
  图片 → 文字                提示 → 回答/生成文本

```

### 感知机无法解决XOR问题

感知机的局限性就在于它只能表示一条直线分割的空间, 对于非线性空间，需要使用曲线分割，如下图：

![perceptron_xor](/images/ai/perceptron_xor.png)

### 多层感知机

逻辑门是计算机最基本的构建块，CPU、算术逻辑单元(ALU)、寄存器等都是由大量逻辑门组合而成的

无限神经元 + 无限层 + 循环记忆 → 可以模拟图灵机 → 理论上可以实现计算机

![perceptron_multilayer](/images/ai/perceptron_multilayer.png)

## 神经元

**线性函数：** 输出值是输入值大常数倍
**非线性函数：** 函数是曲线

### 激活函数-阶跃函数

**阶跃函数**

```py

import numpy as np

import matplotlib.pyplot as plt


def step_function(x):
    return np.array(x > 0, dtype=np.int32)

x = np.arange(-5.0, 5.0, 0.1)
y = step_function(x)

plt.plot(x, y)
plt.ylim(-0.1, 1.1)
plt.title("Step Function")
plt.xlabel("X Axis")
plt.ylabel("Y Axis")
# plt.grid()
plt.show()

```

![step_function](/images/ai/step_function.png)

### Sigmoid 函数

```py

import numpy as np

import matplotlib.pyplot as plt

def sigmoid(x):
    return 1 / (1 + np.exp(-x))

x = np.arange(-10.0, 10.0, 0.1)
y = sigmoid(x)
plt.plot(x, y)
plt.ylim(-0.1, 1.1)
plt.title("Sigmoid Function")
plt.xlabel("X Axis")
plt.ylabel("Y Axis")
# plt.grid()
plt.show()

```

![sigmoid_funtion](/images/ai/sigmoid_funtion.png)

阶跃函数 = 数字电路
Sigmoid = 模拟电路

**深度学习其实是“可微分计算机”，它不是在执行逻辑，而是在优化函数**

### 多维数组的计算

**矩阵乘法**

```py

import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6]])
print(a.ndim)  # 输出数组的维度
print(a.shape)  # 输出数组的形状
print(a.dtype)  # 输出数组中元素的数据类型
print(a.size)  # 输出数组中元素的总数

# 矩阵乘法
# 1 2 3
# 4 5 6
# 乘以
# 7  8
# 9 10
# 11 12

b = np.array([[7, 8], [9, 10], [11, 12]])
c = np.dot(a, b)
print(c)  # 输出矩阵乘法的结果

# 2 x 3 乘以 3 x 2 得到 2 x 2 矩阵

# 58 64
# 139 154

# 矩阵乘法不支持交换律
d = np.dot(b, a)
print(d)  # 输出矩阵乘法的结果

# 3 x 2 乘以 2 x 3 得到 3 x 3 矩阵

# 39 54 69
# 49 68 87
# 59 82 105

# 矩阵乘法的行数和列数必须匹配，否则会报错

```

![matrix_multiplication](/images/ai/matrix_multiplication.png)

**神经网络的内积**

```py

x = np.array([1, 2])
print(x.shape)  # 输出数组的形状
y = np.array([[1, 3, 5], [2, 4,6]])
print(y.shape)  # 输出数组的形状
z = np.dot(x, y)  # 1 x 2 乘以 2 x 3 得到 1 x 3 矩阵
print(z)  # 输出矩阵乘法的结果

```

![matrix_multiplication_2](/images/ai/matrix_multiplication_2.png)

**多层神经元之间传递**

```py

import numpy as np
import matplotlib.pyplot as plt

def sigmoid(x):
    return 1 / (1 + np.exp(-x))

X = np.array([1.0, 0.5]) # 输入层的输入
W1 = np.array([[0.1, 0.3, 0.5], [0.2, 0.4, 0.6]]) # 输入层到隐藏层的权重
B1 = np.array([0.1, 0.2, 0.3]) # 隐藏层的偏置

print("X shape:", X.shape) # （2，）
print("W1 shape:", W1.shape) # （2，3）
print("B1 shape:", B1.shape) # （3，）

A1 = np.dot(X, W1) + B1 # 计算隐藏层的加权和

Z1 = sigmoid(A1) # 计算隐藏层的输出

print(A1) # 输出隐藏层的加权和 [0.3 0.7 1.1]
print(Z1) # 输出隐藏层的输出 [0.57444252 0.66818777 0.75026011]

# 第二层（隐藏层到输出层）
W2 = np.array([[0.1, 0.4], [0.2, 0.5], [0.3, 0.6]]) # 隐藏层到输出层的权重
B2 = np.array([0.1, 0.2]) # 输出层的偏置

A2 = np.dot(Z1, W2) + B2 # 计算输出层的加权和

Z2 = sigmoid(A2) # 计算输出层的输出

print(A2) # 输出输出层的加权和 [0.4 0.8]
print(Z2) # 输出输出层的输出 [0.59868766 0.68997448]

# 第三层（输出层到最终输出）
W3 = np.array([[0.1, 0.3], [0.2, 0.4]]) # 输出层到最终输出的权重
B3 = np.array([0.1, 0.2]) # 最终输出的偏置
A3 = np.dot(Z2, W3) + B3 # 计算最终输出的加权和
Z3 = sigmoid(A3) # 计算最终输出
print(A3) # 输出最终输出的加权和 [0.42336002 0.78658716]

print(Z3) # 输出最终输出 [0.60451623 0.68621873]

```

![multilayer_neuronal_trans](/images/ai/multilayer_neuronal_trans.png)





















