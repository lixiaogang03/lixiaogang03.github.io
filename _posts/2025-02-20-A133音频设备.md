---
layout:     post
title:      A133 éŸ³é¢‘è®¾å¤‡
subtitle:   android 10
date:       2025-02-21
author:     LXG
header-img: img/post-bg-smart_phone.jpg
catalog: true
tags:
    - audio
---

[éŸ³é¢‘-AOSP](https://source.android.google.cn/docs/core/audio?hl=zh-cn)

[Android Framework éŸ³é¢‘å­ç³»ç»Ÿï¼ˆ02ï¼‰éŸ³é¢‘ç³»ç»Ÿæ¡†æ¶](https://blog.csdn.net/vviccc/article/details/105265359)

## AOSP éŸ³é¢‘æ¶æ„

![ape_fwk_audio](/images/android/audio/ape_fwk_audio.png)

## æŸ¥çœ‹éŸ³é¢‘ç¡¬ä»¶å‘½ä»¤

```bash

WIFBY:/ $ cat proc/asound/cards                                                                                                                                                                    
 0 [sun50iw10codec ]: sun50iw10-codec - sun50iw10-codec
                      sun50iw10-codec
 1 [CAMERA         ]: USB-Audio - WN Full HD CAMERA
                      WN-ZW-220419 WN Full HD CAMERA at usb-sunxi-ehci-1.2, high speed

```

| è®¾å¤‡ç´¢å¼• | è®¾å¤‡åç§°               | è®¾å¤‡ç±»å‹          | è¿æ¥æ–¹å¼              | å¤‡æ³¨                     |
|---------|----------------------|---------------|-----------------|----------------------|
| 0       | sun50iw10-codec      | æ¿è½½éŸ³é¢‘è®¾å¤‡      | SoC å†…ç½®            | å¯èƒ½æ˜¯æ‰¬å£°å™¨æˆ– 3.5mm æ¥å£ |
| 1       | WN Full HD CAMERA    | USB éŸ³é¢‘è®¾å¤‡      | USBï¼ˆusb-sunxi-ehci-1.2ï¼‰ | æ‘„åƒå¤´è‡ªå¸¦éº¦å…‹é£        |

## A133 éŸ³é¢‘æ¡†æ¶

![a133_audio](/images/android/audio/a133_audio.png)

åœ¨ A133 ä¸­ï¼Œå­˜åœ¨ 7 ä¸ªéŸ³é¢‘è®¾å¤‡ï¼Œåˆ†åˆ«æ˜¯ï¼š

![a133_audio_hardware](/images/android/audio/a133_audio_hardware.png)

## Linux ALSA

ALSAï¼ˆAdvanced Linux Sound Architectureï¼Œé«˜çº§ Linux å£°éŸ³æ¶æ„ï¼‰ æ˜¯ Linux å†…æ ¸ä¸­çš„ä¸€å¥—éŸ³é¢‘é©±åŠ¨æ¡†æ¶ï¼Œç”¨äºç®¡ç†éŸ³é¢‘è®¾å¤‡ï¼ˆå£°å¡ã€éº¦å…‹é£ã€USB éŸ³é¢‘è®¾å¤‡ç­‰

ASoCï¼ˆALSA System on Chipï¼‰ æ˜¯ ALSAï¼ˆLinux å£°éŸ³æ¶æ„ï¼‰ä¸“é—¨ä¸º SoC è®¾è®¡çš„éŸ³é¢‘å­ç³»ç»Ÿï¼Œç”¨äºç®¡ç†åµŒå…¥å¼ç³»ç»Ÿï¼ˆå¦‚å¼€å‘æ¿ã€æ™ºèƒ½è®¾å¤‡ï¼‰ä¸Šçš„éŸ³é¢‘è®¾å¤‡ã€‚

**ğŸ”¹ ä¸ºä»€ä¹ˆéœ€è¦ ASoCï¼Ÿ**

æ™®é€š PC çš„å£°å¡ä¸€èˆ¬æ˜¯**æ ‡å‡†åŒ–çš„**ï¼ˆå¦‚ Intel HDAã€USB å£°å¡ï¼‰ï¼ŒALSA å¯ä»¥ç›´æ¥æ”¯æŒã€‚ä½†åµŒå…¥å¼ç³»ç»Ÿçš„éŸ³é¢‘ç¡¬ä»¶**åƒå·®ä¸‡åˆ«**ï¼Œéœ€è¦æ›´çµæ´»çš„æ¶æ„æ¥ç®¡ç†ã€‚å› æ­¤ï¼ŒASoC ä¸»è¦è§£å†³ä»¥ä¸‹é—®é¢˜ï¼š

1. **ä¸åŒ SoC èŠ¯ç‰‡çš„éŸ³é¢‘æ§åˆ¶é€»è¾‘ä¸åŒ**ï¼ˆå¦‚ Allwinnerã€Rockchipã€Qualcommã€Amlogicï¼‰
2. **éŸ³é¢‘ç¼–è§£ç å™¨ï¼ˆCodecï¼‰ç§ç±»ç¹å¤š**ï¼ˆä¸åŒå‚å•†ä½¿ç”¨ä¸åŒçš„ DAC/ADC èŠ¯ç‰‡ï¼‰
3. **å¼€å‘æ¿çš„éŸ³é¢‘æ¶æ„å¤æ‚**ï¼ˆå¯èƒ½æœ‰å¤šä¸ª I2S æ¥å£ã€å¤šä¸ªéŸ³é¢‘é€šè·¯ï¼‰
4. **é™ä½é©±åŠ¨ä»£ç é‡å¤**ï¼Œæ–¹ä¾¿ç§»æ¤å’Œç»´æŠ¤


**ğŸ”¹ ASoC ç»“æ„**
ASoC æŠŠ SoC çš„éŸ³é¢‘ç³»ç»Ÿæ‹†åˆ†æˆ**ä¸‰å¤§éƒ¨åˆ†**ï¼Œè¿™æ ·æ›´æ˜“äºé€‚é…ä¸åŒç¡¬ä»¶ï¼š

| ç»„ä»¶ | ä½œç”¨ | ä¾‹å­ |
|------|------|------|
| **Codec é©±åŠ¨** | è´Ÿè´£ç®¡ç† **éŸ³é¢‘ç¼–è§£ç èŠ¯ç‰‡**ï¼ˆDAC/ADCï¼‰ | WM8960ã€ES8316ã€RT5645 |
| **Platform é©±åŠ¨** | è´Ÿè´£ SoC çš„ **I2Sã€DMA ä¼ è¾“** | Allwinner ASoCã€Rockchip I2S |
| **Machine é©±åŠ¨** | æŠŠ **Codec å’Œ Platform è¿æ¥èµ·æ¥**ï¼Œå®šä¹‰éŸ³é¢‘è·¯ç”± | å¼€å‘æ¿çš„éŸ³é¢‘æ‹“æ‰‘ï¼Œæ¯”å¦‚æ‰¬å£°å™¨è¿å“ªä¸ªæ¥å£ |


## A133 éŸ³é¢‘æ¥å£å¯¹æ¯”

| **æ¥å£**        | **ç”¨é€”**                | **ç‰¹ç‚¹**                                      | **é€‚ç”¨åœºæ™¯**                     |
|----------------|------------------------|----------------------------------------------|----------------------------------|
| **I2S**       | å¤–éƒ¨ Codec / DSP       | æ”¯æŒ **192kHz é‡‡æ ·ç‡ã€TDMã€å¤šé€šé“ä¼ è¾“**     | **é«˜è´¨é‡éŸ³é¢‘æ’­æ”¾ã€HiFi è®¾å¤‡**    |
| **PCM**       | è¯­éŸ³é€šè®¯               | å…¼å®¹ **VoIP / è“ç‰™è¯­éŸ³**ï¼Œæ”¯æŒçŸ­å¸§/é•¿å¸§æ¨¡å¼ | **è“ç‰™éŸ³é¢‘ã€å¯¹è®²ç³»ç»Ÿ**          |
| **DMIC**      | æ•°å­—éº¦å…‹é£æ¥å£         | **åŒé€šé“ PDM**ï¼Œç›´è¿ MEMS æ•°å­—éº¦å…‹é£       | **AI è¯­éŸ³åŠ©æ‰‹ã€é™å™ªæ‹¾éŸ³**        |
| **AUDIO CODEC** | å†…éƒ¨éŸ³é¢‘ç¼–è§£ç å™¨       | å†…ç½® **DAC/ADC**ï¼Œç›´é©±è€³æœº/æ‰¬å£°å™¨          | **åŸºç¡€éŸ³é¢‘æ’­æ”¾ã€å½•éŸ³**           |

## éŸ³é¢‘ç³»ç»Ÿåº•å±‚è®¾å¤‡èŠ‚ç‚¹

```bash

WIFBY:/ $ ls dev/snd/
controlC0 controlC1 pcmC0D0c pcmC0D0p pcmC1D0c timer

WIFBY:/ $ cat /proc/asound/pcm
00-00: SUNXI-CODEC sun50iw10codec-0 :  : playback 1 : capture 1
01-00: USB Audio : USB Audio : capture 1

```

| **è®¾å¤‡æ–‡ä»¶**  | **å«ä¹‰** |
|--------------|---------|
| `controlC0`  | **æ§åˆ¶è®¾å¤‡ 0**ï¼ˆç”¨äºæ§åˆ¶éŸ³é¢‘è®¾å¤‡ï¼Œå¦‚ mixer è®¾ç½®ï¼‰ |
| `controlC1`  | **æ§åˆ¶è®¾å¤‡ 1**ï¼ˆå¦‚æœæœ‰å¤šä¸ªå£°å¡ï¼Œæ¯ä¸ªå£°å¡æœ‰è‡ªå·±çš„ control è®¾å¤‡ï¼‰ |
| `pcmC0D0c`   | **PCM è®¾å¤‡ï¼ˆCard 0, Device 0, Captureï¼‰**ï¼Œè¡¨ç¤º**éŸ³é¢‘è¾“å…¥ï¼ˆå½•éŸ³ï¼‰** |
| `pcmC0D0p`   | **PCM è®¾å¤‡ï¼ˆCard 0, Device 0, Playbackï¼‰**ï¼Œè¡¨ç¤º**éŸ³é¢‘è¾“å‡ºï¼ˆæ’­æ”¾ï¼‰** |
| `pcmC1D0c`   | **PCM è®¾å¤‡ï¼ˆCard 1, Device 0, Captureï¼‰**ï¼Œè¡¨ç¤º**ç¬¬äºŒå¼ å£°å¡çš„å½•éŸ³è®¾å¤‡** |
| `timer`      | **éŸ³é¢‘æ—¶é—´åŒæ­¥ç›¸å…³è®¾å¤‡** |


## dumpsys media.audio_policy

RK3568è¯†åˆ«åˆ°äº†USB-Audio - WN Full HD CAMERA

å…¨å¿—A133æ²¡æœ‰è¯†åˆ«åˆ°

```txt
- Available input devices:
  Device 3:
  - id:  9
  - tag name: USB-Audio - WN Full HD CAMERA
  - type: AUDIO_DEVICE_IN_USB_DEVICE                      
  - supported encapsulation modes: 0  - supported encapsulation metadata types: 0  - address: card=2;device=0;                
  - name: USB-Audio - WN Full HD CAMERA
  - Profiles:
      Profile 0:[dynamic format]
          - format: AUDIO_FORMAT_PCM_16_BIT
          - sampling rates:8000, 16000, 44100, 48000
          - channel masks:0x000c, 0x0010, 0x80000001
  Device 4:
  - id:  6
  - tag name: Built-In Mic
  - type: AUDIO_DEVICE_IN_BUILTIN_MIC                     
  - supported encapsulation modes: 0  - supported encapsulation metadata types: 0  - address: bottom                          
  - Profiles:
      Profile 0:[dynamic format][dynamic channels][dynamic rates]
      Profile 1:
          - format: AUDIO_FORMAT_PCM_16_BIT
          - sampling rates:8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000
          - channel masks:0x000c, 0x0010

```

## åˆ†æ

`frameworks/av/services/audiopolicy/managerdefault/AudioPolicyManager.cpp`

```cpp


AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface)
        : AudioPolicyManager(clientInterface, false /*forTesting*/)
{
    loadConfig();
    initialize();
}


void AudioPolicyManager::loadConfig() {
    if (deserializeAudioPolicyXmlConfig(getConfig()) != NO_ERROR) {
        ALOGE("could not load audio policy configuration file, setting defaults");
        getConfig().setDefault();
    }
}

status_t AudioPolicyManager::initialize() {
     // -----------------------------------------

    // mAvailableOutputDevices and mAvailableInputDevices now contain all attached devices
    // open all output streams needed to access attached devices
    for (const auto& hwModule : mHwModulesAll) {
        ALOGI("Processing hardware module: %s", hwModule->getName());  // æ‰“å°æ­£åœ¨å¤„ç†çš„ç¡¬ä»¶æ¨¡å—åç§°

        // æ‰“å°å½“å‰ç¡¬ä»¶æ¨¡å—çš„å¯ç”¨è¾“å‡ºå’Œè¾“å…¥è®¾å¤‡ä¿¡æ¯
        ALOGI("Available input devices for module %s: %s", hwModule->getName(), mAvailableInputDevices.toString().c_str());
        ALOGI("Available output devices for module %s: %s", hwModule->getName(), mAvailableOutputDevices.toString().c_str());

        hwModule->setHandle(mpClientInterface->loadHwModule(hwModule->getName()));
        if (hwModule->getHandle() == AUDIO_MODULE_HANDLE_NONE) {
            ALOGW("could not open HW module %s", hwModule->getName());
            continue;
        }
        mHwModules.push_back(hwModule);
        // open all output streams needed to access attached devices
        // except for direct output streams that are only opened when they are actually
        // required by an app.
        // This also validates mAvailableOutputDevices list
        for (const auto& outProfile : hwModule->getOutputProfiles()) {
             //--------------------------------------------
        }
        // open input streams needed to access attached devices to validate
        // mAvailableInputDevices list
        for (const auto& inProfile : hwModule->getInputProfiles()) {
            if (!inProfile->canOpenNewIo()) {
                ALOGE("Invalid Input profile max open count %u for profile %s",
                      inProfile->maxOpenCount, inProfile->getTagName().c_str());
                continue;
            }
            if (!inProfile->hasSupportedDevices()) {
                ALOGW("Input profile contains no device on module %s", hwModule->getName());
                continue;
            }
            // chose first device present in profile's SupportedDevices also part of
            // available input devices
            const DeviceVector &supportedDevices = inProfile->getSupportedDevices();

            ALOGI("Supported devices for profile %s: %s", inProfile->getTagName().c_str(), supportedDevices.toString().c_str());
            DeviceVector availProfileDevices = supportedDevices.filter(mAvailableInputDevices);
            // æ‰“å°ç­›é€‰åçš„å¯ç”¨è®¾å¤‡åˆ—è¡¨
            ALOGI("Available input devices after filter: %s", availProfileDevices.toString().c_str());
            if (availProfileDevices.isEmpty()) {
                ALOGE("%s: Input device list is empty!", __FUNCTION__);
                continue;
            }

            // --------------------------------------------------
        }
    }

    //----------------------------------------------------------

}

```

**æ—¥å¿—æ‰“å°**

```txt


// åœ¨ Android éŸ³é¢‘ç³»ç»Ÿä¸­ï¼Œprimary æ˜¯ä¸»è¦çš„éŸ³é¢‘ç¡¬ä»¶æ¨¡å—ï¼Œè´Ÿè´£å¤„ç† ä¸»å£°å¡ï¼ˆmain sound cardï¼‰ çš„éŸ³é¢‘è¾“å…¥/è¾“å‡ºã€‚
APM_AudioPolicyManager  pid-2137                             I  Processing hardware module: primary
APM_AudioPolicyManager  pid-2137                             I  Available input devices for module primary: {type:0x80000004,@:;type:0x80000100,@:0}
APM_AudioPolicyManager  pid-2137                             I  Available output devices for module primary: {type:0x2,@:}
APM_AudioPolicyManager  pid-2137                             I  Supported devices for profile primary input: {type:0x80000004,@:;type:0x80000010,@:;type:0x80000008,@:}
APM_AudioPolicyManager  pid-2137                             I  Available input devices after filter: {type:0x80000004,@:}
APM_AudioPolicyManager  pid-2137                             W  Input profile contains no device on module primary

// A2DPï¼ˆAdvanced Audio Distribution Profileï¼‰æ˜¯ è“ç‰™éŸ³é¢‘ä¼ è¾“åè®®ï¼Œç”¨äº è“ç‰™éŸ³ç®±ã€è€³æœºã€è½¦è½½éŸ³å“ç­‰éŸ³é¢‘è¾“å‡ºè®¾å¤‡ã€‚
APM_AudioPolicyManager  pid-2137                             I  Processing hardware module: a2dp
APM_AudioPolicyManager  pid-2137                             I  Available input devices for module a2dp: {type:0x80000004,@:;type:0x80000100,@:0}
APM_AudioPolicyManager  pid-2137                             I  Available output devices for module a2dp: {type:0x2,@:}
APM_AudioPolicyManager  pid-2137                             I  Supported devices for profile a2dp input: {type:0x80020000,@:}
APM_AudioPolicyManager  pid-2137                             I  Available input devices after filter: AUDIO_DEVICE_NONE
APM_AudioPolicyManager  pid-2137                             E  initialize: Input device list is empty!



APM_AudioPolicyManager  pid-2137                             I  Processing hardware module: usb
APM_AudioPolicyManager  pid-2137                             I  Available input devices for module usb: {type:0x80000004,@:;type:0x80000100,@:0}
APM_AudioPolicyManager  pid-2137                             I  Available output devices for module usb: {type:0x2,@:}
APM_AudioPolicyManager  pid-2137                             I  Supported devices for profile usb_device input: {type:0x80001000,@:;type:0x82000000,@:}
APM_AudioPolicyManager  pid-2137                             I  Available input devices after filter: AUDIO_DEVICE_NONE
APM_AudioPolicyManager  pid-2137                             E  initialize: Input device list is empty!


// r_submixï¼ˆRemote Submixï¼‰æ˜¯ Android çš„ è™šæ‹ŸéŸ³é¢‘è®¾å¤‡
APM_AudioPolicyManager  pid-2137                             I  Processing hardware module: r_submix
APM_AudioPolicyManager  pid-2137                             I  Available input devices for module r_submix: {type:0x80000004,@:;type:0x80000100,@:0}
APM_AudioPolicyManager  pid-2137                             I  Available output devices for module r_submix: {type:0x2,@:}
APM_AudioPolicyManager  pid-2137                             I  Supported devices for profile r_submix input: {type:0x80000100,@:0}
APM_AudioPolicyManager  pid-2137                             I  Available input devices after filter: {type:0x80000100,@:0}


```

**è®¾å¤‡ç±»å‹å®šä¹‰**

`./system/media/audio/include/system/audio-base.h`

```c

enum {

    AUDIO_DEVICE_IN_BUILTIN_MIC                = 0x80000004u, // BIT_IN | 0x4
    AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET      = 0x80000008u, // BIT_IN | 0x8
    AUDIO_DEVICE_IN_WIRED_HEADSET              = 0x80000010u, // BIT_IN | 0x10
    AUDIO_DEVICE_IN_REMOTE_SUBMIX              = 0x80000100u, // BIT_IN | 0x100
    AUDIO_DEVICE_IN_USB_DEVICE                 = 0x80001000u, // BIT_IN | 0x1000
}

```

**åˆ†æ**

æœªè¯†åˆ«åˆ° AUDIO_DEVICE_IN_USB_DEVICE(0x80001000u) è®¾å¤‡


**æ’æŸ¥audio_policy**

`vendor/etc/audio_policy_configuration.xml`

```xml

<audioPolicyConfiguration version="1.0" xmlns:xi="http://www.w3.org/2001/XInclude">
    <globalConfiguration speaker_drc_enabled="true"/>

    <modules>
        <module name="primary" halVersion="2.0">
            <attachedDevices>
                <item>Speaker</item>
                <item>Built-In Mic</item>
            </attachedDevices>
            <defaultOutputDevice>Speaker</defaultOutputDevice>
            <mixPorts>
                <mixPort name="primary output" role="source" flags="AUDIO_OUTPUT_FLAG_PRIMARY">
                    <profile name="" format="AUDIO_FORMAT_PCM_16_BIT"
                             samplingRates="48000" channelMasks="AUDIO_CHANNEL_OUT_STEREO"/>
                </mixPort>
                <!--
                <mixPort name="hdmi output" role="source" flags="AUDIO_OUTPUT_FLAG_DIRECT">
                    <profile name="" format="AUDIO_FORMAT_PCM_16_BIT"
                             samplingRates="44100,48000" channelMasks="dynamic"/>
                </mixPort>
                -->
                <mixPort name="primary input" role="sink">
                    <profile name="" format="AUDIO_FORMAT_PCM_16_BIT"
                             samplingRates="8000,11025,12000,16000,22050,24000,32000,44100,48000"
                             channelMasks="AUDIO_CHANNEL_IN_MONO,AUDIO_CHANNEL_IN_STEREO"/>
                </mixPort>
                <mixPort name="fast input" role="sink" flags="AUDIO_INPUT_FLAG_FAST">
                    <profile name="" format="AUDIO_FORMAT_PCM_16_BIT"
                             samplingRates="8000,11025,12000,16000,22050,24000,32000,44100,48000"
                             channelMasks="AUDIO_CHANNEL_IN_MONO,AUDIO_CHANNEL_IN_STEREO"/>
                </mixPort>
            </mixPorts>
            <devicePorts>
                <devicePort tagName="Speaker" type="AUDIO_DEVICE_OUT_SPEAKER" role="sink">
                </devicePort>
                <devicePort tagName="Wired Headset" type="AUDIO_DEVICE_OUT_WIRED_HEADSET" role="sink">
                </devicePort>
                <devicePort tagName="Wired Headphones" type="AUDIO_DEVICE_OUT_WIRED_HEADPHONE" role="sink">
                </devicePort>
                <devicePort tagName="BT SCO" type="AUDIO_DEVICE_OUT_BLUETOOTH_SCO" role="sink">
                </devicePort>
                <devicePort tagName="BT SCO Headset" type="AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET" role="sink">
                </devicePort>
                <devicePort tagName="BT SCO Car Kit" type="AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT" role="sink">
                </devicePort>
                <devicePort tagName="HDMI Out" type="AUDIO_DEVICE_OUT_AUX_DIGITAL" role="sink">
                </devicePort>

                <devicePort tagName="Built-In Mic" type="AUDIO_DEVICE_IN_BUILTIN_MIC" role="source">
                </devicePort>
                <devicePort tagName="Wired Headset Mic" type="AUDIO_DEVICE_IN_WIRED_HEADSET" role="source">
                </devicePort>
                <devicePort tagName="BT SCO Headset Mic" type="AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET" role="source">
                </devicePort>
            </devicePorts>
            <routes>
                <route type="mix" sink="Speaker"
                       sources="primary output"/>
                <route type="mix" sink="Wired Headset"
                       sources="primary output"/>
                <route type="mix" sink="Wired Headphones"
                       sources="primary output"/>
                <route type="mix" sink="BT SCO"
                       sources="primary output"/>
                <route type="mix" sink="BT SCO Headset"
                       sources="primary output"/>
                <route type="mix" sink="BT SCO Car Kit"
                       sources="primary output"/>
                <!--
                <route type="mix" sink="HDMI Out"
                       sources="hdmi output"/>
                -->

                <route type="mix" sink="primary input"
                       sources="Built-In Mic,Wired Headset Mic,BT SCO Headset Mic"/>
            </routes>
        </module>

        <!-- A2dp Audio HAL -->
        <xi:include href="a2dp_audio_policy_configuration.xml"/>

        <!-- Usb Audio HAL -->
        <xi:include href="usb_audio_policy_configuration.xml"/>

        <!-- Remote Submix Audio HAL -->
        <xi:include href="r_submix_audio_policy_configuration.xml"/>

    </modules>

    <!-- Volume section -->
    <xi:include href="audio_policy_volumes_drc.xml"/>
    <xi:include href="ceres_volume_tables.xml"/>

</audioPolicyConfiguration>


```

`vendor/etc/usb_audio_policy_configuration.xml`

```xml

<!-- USB Audio HAL Audio Policy Configuration file -->

<module name="usb" halVersion="2.0">
    <mixPorts>
        <mixPort name="usb_accessory output" role="source">
            <profile name="" format="AUDIO_FORMAT_PCM_16_BIT"
                     samplingRates="44100" channelMasks="AUDIO_CHANNEL_OUT_STEREO"/>
        </mixPort>
        <mixPort name="usb_device output" role="source"/>
        <mixPort name="usb_device input" role="sink"/>
    </mixPorts>
    <devicePorts>
        <devicePort tagName="USB Host Out" type="AUDIO_DEVICE_OUT_USB_ACCESSORY" role="sink">
            <profile name="" format="AUDIO_FORMAT_PCM_16_BIT"
                     samplingRates="44100" channelMasks="AUDIO_CHANNEL_OUT_STEREO"/>
        </devicePort>
        <devicePort tagName="USB Device Out" type="AUDIO_DEVICE_OUT_USB_DEVICE" role="sink"/>
        <devicePort tagName="USB Headset Out" type="AUDIO_DEVICE_OUT_USB_HEADSET" role="sink"/>
        <devicePort tagName="USB Device In" type="AUDIO_DEVICE_IN_USB_DEVICE" role="source"/>
        <devicePort tagName="USB Headset In" type="AUDIO_DEVICE_IN_USB_HEADSET" role="source"/>
    </devicePorts>
    <routes>
        <route type="mix" sink="USB Host Out"
               sources="usb_accessory output"/>
        <route type="mix" sink="USB Device Out"
               sources="usb_device output"/>
        <route type="mix" sink="USB Headset Out"
               sources="usb_device output"/>
        <route type="mix" sink="usb_device input"
               sources="USB Device In,USB Headset In"/>
    </routes>
</module>

```

## USB ç›¸æœºæ’å…¥å†…æ ¸æ—¥å¿—

**ç¡®è®¤ USB éŸ³é¢‘è®¾å¤‡åœ¨å†…æ ¸ä¸­è¢«è¯†åˆ«**

```txt

// A133 æ—¥å¿—

[   97.851385] usb 1-1.2: USB disconnect, device number 3
[  108.244471] usb 1-1.2: new high-speed USB device number 4 using sunxi-ehci
[  108.720295] uvcvideo: Found UVC 1.00 device WN Full HD CAMERA (1bcf:2281)
[  108.750790] uvcvideo 1-1.2:1.0: Entity type for entity Extension 3 was not initialized!
[  108.759967] uvcvideo 1-1.2:1.0: Entity type for entity Processing 2 was not initialized!
[  108.769143] uvcvideo 1-1.2:1.0: Entity type for entity Camera 1 was not initialized!
[  108.781324] input: WN Full HD CAMERA as /devices/platform/soc/5200000.ehci1-controller/usb1/1-1/1-1.2/1-1.2:1.0/input/input5
[  108.845166] usb 1-1.2: Warning! Unlikely big volume range (=4096), cval->res is probably wrong.
[  108.855330] usb 1-1.2: [5] FU [Mic Capture Volume] ch = 1, val = 0/4096/1

// rk3568 æ—¥å¿—

[   34.176719] usb 5-1: new high-speed USB device number 3 using xhci-hcd
[   34.565305] usb 5-1: New USB device found, idVendor=1bcf, idProduct=2281, bcdDevice= 4.19
[   34.565339] usb 5-1: New USB device strings: Mfr=1, Product=2, SerialNumber=0
[   34.565346] usb 5-1: Product: WN Full HD CAMERA
[   34.565353] usb 5-1: Manufacturer: WN-ZW-220419
[   34.822802] uvcvideo: Found UVC 1.00 device WN Full HD CAMERA (1bcf:2281)
[   34.867343] input: WN Full HD CAMERA: WN Full HD C as /devices/platform/usbhost/fd000000.dwc3/xhci-hcd.1.auto/usb5/5-1/5-1:1.0/input/input6
[   34.963920] usb 5-1: Warning! Unlikely big volume range (=4096), cval->res is probably wrong.
[   34.963955] usb 5-1: [5] FU [Mic Capture Volume] ch = 1, val = 0/4096/1

```

## lshal å¯¹æ¯”

lshalï¼ˆList HALsï¼‰æ˜¯ Android çš„ä¸€ä¸ªå‘½ä»¤è¡Œå·¥å…·ï¼Œç”¨äºåˆ—å‡º æ‰€æœ‰å·²æ³¨å†Œçš„ HALï¼ˆHardware Abstraction Layerï¼‰æ¥å£ã€‚å®ƒä¸»è¦ç”¨äº è°ƒè¯•å’ŒéªŒè¯ HAL å±‚æ˜¯å¦æ­£ç¡®åŠ è½½ï¼Œç‰¹åˆ«æ˜¯ éŸ³é¢‘ã€æ‘„åƒå¤´ã€USB ç­‰è®¾å¤‡çš„ HALã€‚

lshal é€‚ç”¨äº Treble æ¶æ„ï¼ˆAndroid 8.0+ï¼‰ï¼Œå¯ä»¥ç”¨äºæŸ¥çœ‹ HIDLï¼ˆHAL Interface Definition Languageï¼‰ å’Œ AIDLï¼ˆAndroid Interface Definition Languageï¼‰ ä¸¤ç§ HALã€‚

```txt

A133:/ $ lshal | grep audio
DM,FC Y android.hardware.audio.effect@5.0::IEffectsFactory/default                0/3        1822   1839 1651
DM,FC Y android.hardware.audio@5.0::IDevicesFactory/default                       0/3        1822   1839 1651
FC    ? android.hardware.audio.effect@5.0::IEffectsFactory/default       N/A        1822   1822
FC    ? android.hardware.audio@5.0::IDevicesFactory/default              N/A        1822   1822
FC    ? android.hardware.audio.effect@5.0::I*/* (/vendor/lib/hw/)           N/A        N/A    
FC    ? android.hardware.audio@5.0::I*/* (/vendor/lib/hw/)                  N/A        N/A  


rk3568_r:/ $ lshal | grep audio
DM,FC Y android.hardware.audio.effect@6.0::IEffectsFactory/default                0/3        278    298 154
DM,FC Y android.hardware.audio@6.0::IDevicesFactory/default                       0/3        278    298 154
FC    ? android.hardware.audio.effect@6.0::IEffectsFactory/default       N/A        278    278
FC    ? android.hardware.audio@6.0::IDevicesFactory/default              N/A        278    278
X     ? android.hardware.audio.effect@6.0::I*/* (/vendor/lib/hw/)                    N/A        N/A    
X     ? android.hardware.audio.effect@6.0::I*/* (/vendor/lib64/hw/)                  N/A        N/A    
X     ? android.hardware.audio@6.0::I*/* (/vendor/lib/hw/)                           N/A        N/A    
X     ? android.hardware.audio@6.0::I*/* (/vendor/lib64/hw/)                         N/A        N/A 

```

## HwModule

`frameworks/av/services/audiopolicy/common/managerdefinitions/src/HwModule.cpp`

```cpp

HwModule::HwModule(const char *name, uint32_t halVersionMajor, uint32_t halVersionMinor)
    : mName(String8(name)),
      mHandle(AUDIO_MODULE_HANDLE_NONE)
{
    setHalVersion(halVersionMajor, halVersionMinor);
}

HwModule::~HwModule()
{
    for (size_t i = 0; i < mOutputProfiles.size(); i++) {
        mOutputProfiles[i]->clearSupportedDevices();
    }
    for (size_t i = 0; i < mInputProfiles.size(); i++) {
        mInputProfiles[i]->clearSupportedDevices();
    }
}

void HwModuleCollection::dump(String8 *dst) const
{
    dst->append("\nHW Modules dump:\n");
    for (size_t i = 0; i < size(); i++) {
        dst->appendFormat("- HW Module %zu:\n", i + 1);
        itemAt(i)->dump(dst);
    }
}

sp<DeviceDescriptor> HwModuleCollection::createDevice(const audio_devices_t type,
                                                      const char *address,
                                                      const char *name,
                                                      const audio_format_t encodedFormat) const
{
    sp<HwModule> hwModule = getModuleForDeviceTypes(type, encodedFormat);
    if (hwModule == 0) {
        ALOGE("%s: could not find HW module for device %04x address %s", __FUNCTION__, type,
              address);
        return nullptr;
    }
    sp<DeviceDescriptor> device = new DeviceDescriptor(type, String8(name));
    device->setName(String8(name));
    device->setAddress(String8(address));
    device->setEncodedFormat(encodedFormat);

  // Add the device to the list of dynamic devices
    hwModule->addDynamicDevice(device);
    // Reciprocally attach the device to the module
    device->attach(hwModule);
    ALOGD("%s: adding dynamic device %s to module %s", __FUNCTION__,
          device->toString().c_str(), hwModule->getName());

    const auto &profiles = (audio_is_output_device(type) ? hwModule->getOutputProfiles() :
                                                             hwModule->getInputProfiles());
    for (const auto &profile : profiles) {
        // Add the device as supported to all profile supporting "weakly" or not the device
        // according to its type
        if (profile->supportsDevice(device, false /*matchAdress*/)) {

            // @todo quid of audio profile? import the profile from device of the same type?
            const auto &isoTypeDeviceForProfile =
                profile->getSupportedDevices().getDevice(type, String8(), AUDIO_FORMAT_DEFAULT);
            device->importAudioPort(isoTypeDeviceForProfile, true /* force */);

            ALOGV("%s: adding device %s to profile %s", __FUNCTION__,
                  device->toString().c_str(), profile->getTagName().c_str());
            profile->addSupportedDevice(device);
        }
    }
    return device;
}

```

**rk3568æ’å…¥USBæ‘„åƒå¤´æ­£å¸¸æ—¥å¿—**

```txt

2025-02-21 14:11:40.070   305-421   APM::HwModule           audioserver                          D  createDevice: adding dynamic device type:0x80001000,@:card=2;device=0; to module usb
2025-02-21 14:11:40.071   305-421   APM::HwModule           audioserver                          V  createDevice: adding device type:0x80001000,@:card=2;device=0; to profile usb_device input

```

## UsbAlsaManager

UsbAlsaManager çš„å·¥ä½œåŸç†å°±æ˜¯åœ¨ç”¨æˆ·æ’å…¥ USB éŸ³é¢‘è®¾å¤‡æ—¶ï¼Œè¯†åˆ«è¯¥è®¾å¤‡å¹¶ä¸ºå…¶é…ç½® ALSA éŸ³é¢‘æ¥å£ã€‚å®ƒè´Ÿè´£ç®¡ç†è®¾å¤‡ç”Ÿå‘½å‘¨æœŸã€è·¯ç”±éŸ³é¢‘æµã€éŸ³é‡æ§åˆ¶å’Œè®¾å¤‡çŠ¶æ€æ›´æ–°ã€‚é€šè¿‡ä¸ ALSA ç³»ç»Ÿå’Œ Android éŸ³é¢‘ç­–ç•¥ç³»ç»Ÿçš„åä½œï¼ŒUsbAlsaManager ç¡®ä¿ USB éŸ³é¢‘è®¾å¤‡èƒ½å¤Ÿä¸ Android ç³»ç»Ÿæ— ç¼é›†æˆã€‚

**A133 æ—¥å¿—**

```txt

2025-02-21 14:55:38.083  2382-3170  UsbAlsaManager          system_server                        D  usbDeviceAdded(): WN-ZW-220419 nm:WN Full HD CAMERA
2025-02-21 14:55:38.088  2382-3170  UsbAlsaManager          system_server                        D  hasInput: false hasOutput:false
2025-02-21 16:06:01.733  2072-2797  UsbDescriptorParser     system_server                        D  parseDescriptors() - end 76 descriptors.
2025-02-21 16:06:02.295  2072-2797  UsbDescriptorParser     system_server                        D  ---- hasInput()
2025-02-21 16:06:02.301  2072-2797  UsbDescriptorParser     system_server                        D  hasInput() = false
2025-02-21 14:55:38.088  2382-3170  UsbAlsaManager          system_server                        D  hasMidi: false mHasMidiFeature:true
2025-02-21 14:55:38.088  2382-3170  UsbAlsaManager          system_server                        I  deviceAdded()----------------
2025-02-21 14:55:38.088  2382-3170  UsbAlsaManager          system_server                        I  ----------------
2025-02-21 14:55:38.088  2382-3170  UsbAlsaManager          system_server                        D  deviceAdded() - done

```

**rk3568æ—¥å¿—**

```txt

2025-02-21 15:37:53.775  2068-2797  UsbHostManager          system_server                        D  USB device attached: vidpid 1bcf:2281 mfg/product/ver/serial WN-ZW-220419/WN Full HD CAMERA/4.19/null hasAudio/HID/Storage: true/false/false
2025-02-21 15:37:53.790  2068-2797  UsbDeviceDescriptor     system_server                        D    1 configs
2025-02-21 15:37:53.808  2068-2797  UsbHostManager          system_server                        D  Added device UsbDevice[mName=/dev/bus/usb/001/005,mVendorId=7119,mProductId=8833,mClass=239,mSubclass=2,mProtocol=1,mManufacturerName=WN-ZW-220419,mProductName=WN Full HD CAMERA,mVersion=4.19,mSerialNumberReader=com.android.server.usb.UsbSerialReader@47af08f,mConfigurations=[
                                                                                                    UsbConfiguration[mId=1,mName=null,mAttributes=128,mMaxPower=250,mInterfaces=[
                                                                                                    UsbInterface[mId=0,mAlternateSetting=0,mName=WN Full HD CAMERA,mClass=14,mSubclass=1,mProtocol=0,mEndpoints=[

2025-02-21 15:17:36.192   465-726   UsbAlsaManager          system_process                       D  usbDeviceAdded(): WN-ZW-220419 nm:WN Full HD CAMERA
2025-02-21 15:17:36.196   465-726   UsbAlsaManager          system_process                       D  hasInput: true hasOutput:false
2025-02-21 16:41:39.962   466-720   UsbDescriptorParser     system_process                       D  ---- hasInput()
2025-02-21 16:41:39.963   466-720   UsbDescriptorParser     system_process                       D    type:0x201
2025-02-21 16:41:39.963   466-720   UsbDescriptorParser     system_process                       D  hasInput() = true
2025-02-21 15:17:36.198   465-726   UsbAlsaManager          system_process                       D  selectAlsaDevice() UsbAlsaDevice: [card: 2, device: 0, name: USB-Audio - WN Full HD CAMERA, hasOutput: false, hasInput: true]
2025-02-21 15:17:36.200   465-726   UsbAlsaDevice           system_process                       I  INPUT JACK connected: true
2025-02-21 15:17:36.203   465-726   UsbAlsaManager          system_process                       D  selectAlsaDevice() - done.
2025-02-21 15:17:36.203   465-726   UsbAlsaManager          system_process                       D  hasMidi: false mHasMidiFeature:false
2025-02-21 15:17:36.203   465-726   UsbAlsaManager          system_process                       I  deviceAdded()----------------
2025-02-21 15:17:36.203   465-726   UsbAlsaManager          system_process                       I  [card:2 device:0 USB-Audio - WN Full HD CAMERA]
2025-02-21 15:17:36.203   465-726   UsbAlsaManager          system_process                       I  ----------------
2025-02-21 15:17:36.203   465-726   UsbAlsaManager          system_process                       D  deviceAdded() - done

```

**æºç **

`frameworks/base/services/usb/java/com/android/server/usb/UsbAlsaManager.java`

```java

public final class UsbAlsaManager {

    /* package */ void usbDeviceAdded(String deviceAddress, UsbDevice usbDevice,
            UsbDescriptorParser parser) {
        if (DEBUG) {
            Slog.d(TAG, "usbDeviceAdded(): " + usbDevice.getManufacturerName()
                    + " nm:" + usbDevice.getProductName());
        }

        // Scan the Alsa File Space
        mCardsParser.scan();

        // Find the ALSA spec for this device address
        AlsaCardsParser.AlsaCardRecord cardRec =
                mCardsParser.findCardNumFor(deviceAddress);
        if (cardRec == null) {
            return;
        }

        // Add it to the devices list
        boolean hasInput = parser.hasInput()   // å…³é”®ç‚¹
                && !isDeviceBlacklisted(usbDevice.getVendorId(), usbDevice.getProductId(),
                        USB_BLACKLIST_INPUT);
        boolean hasOutput = parser.hasOutput()
                && !isDeviceBlacklisted(usbDevice.getVendorId(), usbDevice.getProductId(),
                        USB_BLACKLIST_OUTPUT);
        if (DEBUG) {
            Slog.d(TAG, "hasInput: " + hasInput + " hasOutput:" + hasOutput);
        }
        if (hasInput || hasOutput) {
            boolean isInputHeadset = parser.isInputHeadset();
            boolean isOutputHeadset = parser.isOutputHeadset();

            if (mAudioService == null) {
                Slog.e(TAG, "no AudioService");
                return;
            }

            UsbAlsaDevice alsaDevice =
                    new UsbAlsaDevice(mAudioService, cardRec.getCardNum(), 0 /*device*/,
                                      deviceAddress, hasOutput, hasInput,
                                      isInputHeadset, isOutputHeadset);
            if (alsaDevice != null) {
                alsaDevice.setDeviceNameAndDescription(
                          cardRec.getCardName(), cardRec.getCardDescription());
                mAlsaDevices.add(0, alsaDevice);
                selectAlsaDevice(alsaDevice);
            }
        }

        //-------------------------------------------------------

        logDevices("deviceAdded()");

        if (DEBUG) {
            Slog.d(TAG, "deviceAdded() - done");
        }
    }
    
}

```

`frameworks/base/services/core/jni/com_android_server_UsbHostManager.cpp`

```cpp

static int usb_device_added(const char *devAddress, void* clientData) {
    struct usb_device *device = usb_device_open(devAddress);
    if (!device) {
        ALOGE("usb_device_open failed\n");
        return 0;
    }

    const usb_device_descriptor* deviceDesc = usb_device_get_device_descriptor(device);
    int classID = deviceDesc->bDeviceClass;
    int subClassID = deviceDesc->bDeviceSubClass;

    // get the raw descriptors
    int numBytes = usb_device_get_descriptors_length(device);
    if (numBytes > 0) {
        JNIEnv* env = AndroidRuntime::getJNIEnv();
        jobject thiz = (jobject)clientData;
        jstring deviceAddress = env->NewStringUTF(devAddress);

        jbyteArray descriptorsArray = env->NewByteArray(numBytes);
        const jbyte* rawDescriptors = (const jbyte*)usb_device_get_raw_descriptors(device);
        env->SetByteArrayRegion(descriptorsArray, 0, numBytes, rawDescriptors);

        env->CallBooleanMethod(thiz, method_usbDeviceAdded,
                deviceAddress, classID, subClassID, descriptorsArray);

        env->DeleteLocalRef(descriptorsArray);
        env->DeleteLocalRef(deviceAddress);

        checkAndClearExceptionFromCallback(env, __FUNCTION__);
    } else {
        // TODO return an error code here?
        ALOGE("error reading descriptors\n");
    }

    usb_device_close(device);

    return 0;
}

static void android_server_UsbHostManager_monitorUsbHostBus(JNIEnv* /* env */, jobject thiz)
{
    struct usb_host_context* context = usb_host_init();
    if (!context) {
        ALOGE("usb_host_init failed");
        return;
    }
    // this will never return so it is safe to pass thiz directly
    usb_host_run(context, usb_device_added, usb_device_removed, NULL, (void *)thiz);
}

```

`frameworks/base/services/usb/java/com/android/server/usb/descriptors/UsbDescriptorParser.java`

```java

public final class UsbDescriptorParser {

    /**
     * @hide
     */
    public void parseDescriptors(byte[] descriptors) {
        if (DEBUG) {
            Log.d(TAG, "parseDescriptors() - start");
        }

        ByteStream stream = new ByteStream(descriptors);
        while (stream.available() > 0) {
            UsbDescriptor descriptor = null;
            try {
                descriptor = allocDescriptor(stream);
            } catch (Exception ex) {
                Log.e(TAG, "Exception allocating USB descriptor.", ex);
            }

            if (descriptor != null) {
                // Parse
                try {
                    descriptor.parseRawDescriptors(stream);

                    // Clean up
                    descriptor.postParse(stream);
                } catch (Exception ex) {
                    Log.e(TAG, "Exception parsing USB descriptors.", ex);

                    // Clean up
                    descriptor.setStatus(UsbDescriptor.STATUS_PARSE_EXCEPTION);
                } finally {
                    // Add descriptor to list
                    if (DEBUG) {
                        Log.d(TAG, "Adding descriptor to list: " + descriptor.getType());
                    }
                    mDescriptors.add(descriptor);
                }
            }
        }
        if (DEBUG) {
            Log.d(TAG, "parseDescriptors() - end " + mDescriptors.size() + " descriptors.");
        }
    }

    private UsbDescriptor allocDescriptor(ByteStream stream)
            throws UsbDescriptorsStreamFormatException {
        stream.resetReadCount();

        int length = stream.getUnsignedByte();
        byte type = stream.getByte();

        UsbDescriptor descriptor = null;
        switch (type) {
            //--------------------------------------------------------

            /*
             * Audio Class Specific
             */
            case UsbDescriptor.DESCRIPTORTYPE_AUDIO_INTERFACE:
                // å…³é”®ç‚¹
                Log.e(TAG, "DESCRIPTORTYPE_AUDIO_INTERFACE");
                int devClass = mDeviceDescriptor.getDevClass();
                Log.e(TAG, "Device Class: 0x" + Integer.toHexString(devClass));
                if (devClass == UsbDescriptor.CLASSID_AUDIO) {
                    Log.e(TAG, "DESCRIPTORTYPE_AUDIO_INTERFACE-----UsbACInterface.allocDescriptor");
                    descriptor = UsbACInterface.allocDescriptor(this, stream, length, type);
                } else {
                    Log.e(TAG, "Skipping non-audio USB device.");
                }
                break;

            case UsbDescriptor.DESCRIPTORTYPE_AUDIO_ENDPOINT:
                descriptor = UsbACEndpoint.allocDescriptor(this, length, type);
                break;

            default:
                break;
        }

        if (descriptor == null) {
            // Unknown Descriptor
            Log.i(TAG, "Unknown Descriptor len: " + length + " type:0x"
                    + Integer.toHexString(type));
            descriptor = new UsbUnknown(length, type);
        }

        return descriptor;

    /*
     * Attribute predicates
     */
    /**
     * @hide
     */
    public boolean hasInput() {
        if (DEBUG) {
            Log.d(TAG, "---- hasInput()");
        }
        // è·å–éŸ³é¢‘æ§åˆ¶æ¥å£æè¿°ç¬¦
        ArrayList<UsbDescriptor> acDescriptors =
                getACInterfaceDescriptors(UsbACInterface.ACI_INPUT_TERMINAL,
                UsbACInterface.AUDIO_AUDIOCONTROL);
        boolean hasInput = false;
        // éå† acDescriptorsï¼ˆéŸ³é¢‘æ§åˆ¶æè¿°ç¬¦åˆ—è¡¨ï¼‰ï¼Œæ£€æŸ¥æ˜¯å¦å­˜åœ¨ æœ‰æ•ˆçš„éŸ³é¢‘è¾“å…¥ç»ˆç«¯ã€‚
        for (UsbDescriptor descriptor : acDescriptors) {
            if (descriptor instanceof UsbACTerminal) {
                UsbACTerminal inDescr = (UsbACTerminal) descriptor;
                // Check for input and bi-directional terminal types
                int type = inDescr.getTerminalType();
                if (DEBUG) {
                    Log.d(TAG, "  type:0x" + Integer.toHexString(type));
                }
                int terminalCategory = type & ~0xFF;
                if (terminalCategory != UsbTerminalTypes.TERMINAL_USB_UNDEFINED
                        && terminalCategory != UsbTerminalTypes.TERMINAL_OUT_UNDEFINED) {
                    // If not explicitly a USB connection or output, it could be an input.
                    hasInput = true;
                    break;
                }
            } else {
                Log.w(TAG, "Undefined Audio Input terminal l: " + descriptor.getLength()
                        + " t:0x" + Integer.toHexString(descriptor.getType()));
            }
        }

        if (DEBUG) {
            Log.d(TAG, "hasInput() = " + hasInput);
        }
        return hasInput;
    }
}

```

**æ—¥å¿—**

```txt

UsbDescriptorParser     system_server                        E  DESCRIPTORTYPE_AUDIO_INTERFACE
UsbDescriptorParser     system_server                        E  Device Class: 0xef
UsbDescriptorParser     system_server                        E  Skipping non-audio USB device.
UsbDescriptorParser     system_server                        I  Unknown Descriptor len: 9 type:0x24

```

ä»æ—¥å¿—ä¸Šåˆ†æint devClass = mDeviceDescriptor.getDevClass() è·å–åˆ°çš„å€¼æ˜¯0xef, è€ŒUsbDescriptor.CLASSID_AUDIOçš„å€¼ä¸º0x01, å¯¼è‡´USBæè¿°ç¬¦æ— æ³•è§£ææˆéŸ³é¢‘è®¾å¤‡

**ç»¼ä¸Šåˆ†æ: è¯¥USBéŸ³é¢‘æè¿°ç¬¦æ— æ³•è¯†åˆ«**

## ä¿®æ”¹æ–¹æ¡ˆ

```diff

diff --git a/android/frameworks/base/services/usb/java/com/android/server/usb/descriptors/UsbDescriptorParser.java b/android/frameworks/base/services/usb/java/com/android/server/usb/descriptors/UsbDescriptorParser.java
index 87b0b77b12..ded5d05116 100755
--- a/android/frameworks/base/services/usb/java/com/android/server/usb/descriptors/UsbDescriptorParser.java
+++ b/android/frameworks/base/services/usb/java/com/android/server/usb/descriptors/UsbDescriptorParser.java
@@ -177,15 +177,17 @@ public final class UsbDescriptorParser {
              * Audio Class Specific
              */
             case UsbDescriptor.DESCRIPTORTYPE_AUDIO_INTERFACE:
-                               if (mDeviceDescriptor.getDevClass() == UsbDescriptor.CLASSID_AUDIO) {
+                               // delete by lixiaogang for usb mic
+                               // if (mDeviceDescriptor.getDevClass() == UsbDescriptor.CLASSID_AUDIO) {
                                        descriptor = UsbACInterface.allocDescriptor(this, stream, length, type);
-                               }
+                               // }
                 break;

             case UsbDescriptor.DESCRIPTORTYPE_AUDIO_ENDPOINT:
-                               if (mDeviceDescriptor.getDevClass() == UsbDescriptor.CLASSID_AUDIO) {
+                               // delete by lixiaogang for usb mic
+                               // if (mDeviceDescriptor.getDevClass() == UsbDescriptor.CLASSID_AUDIO) {
                                        descriptor = UsbACEndpoint.allocDescriptor(this, length, type);
-                               }
+                               // }
                 break;

             default:
diff --git a/android/packages/apps/Camera2/src/com/android/camera/VideoModule.java b/android/packages/apps/Camera2/src/com/android/camera/VideoModule.java
index 7ee70c1a62..5e575c4337 100644
--- a/android/packages/apps/Camera2/src/com/android/camera/VideoModule.java
+++ b/android/packages/apps/Camera2/src/com/android/camera/VideoModule.java
@@ -1154,7 +1154,7 @@ public class VideoModule extends CameraModule
         }

         mMediaRecorder.setCamera(camera);
-        mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
+        mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.UNPROCESSED);
         mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);
         mMediaRecorder.setProfile(mProfile);


```



















