---
layout:     post
title:      RK3588 åŒä»¥å¤ªç½‘
subtitle:   android 12
date:       2025-07-16
author:     LXG
header-img: img/post-bg-sky.jpg
catalog: true
tags:
    - rk3588
---

[rk-ethernet](https://github.com/Poco-Ye/rk-ethernet?search=1)

## å¯åŠ¨æµç¨‹

#### å¯åŠ¨æ—¥å¿—

```bash

2025-07-16 10:12:04.185   609-609   SystemServerTiming      system_server                        D  StartEthernet
2025-07-16 10:12:04.185   609-609   SystemServiceManager    system_server                        I  Starting com.android.server.ethernet.EthernetService
2025-07-16 10:12:04.185   609-609   EthernetService         system_server                        I  Registering service ethernet
2025-07-16 10:12:04.494   609-609   SystemServerTiming      system_server                        D  OnBootPhase_480_com.android.server.ethernet.EthernetService
2025-07-16 10:12:04.512   609-609   SystemServerTiming      system_server                        D  OnBootPhase_500_com.android.server.ethernet.EthernetService
2025-07-16 10:12:04.512   609-609   EthernetServiceImpl     system_server                        I  Starting Ethernet service
2025-07-16 10:12:04.513   609-609   EthernetTracker         system_server                        D  Interface match regexp set to 'eth1'
2025-07-16 10:12:04.514   609-609   Ethernet                system_server                        D  Registering NetworkFactory
2025-07-16 10:12:04.514   609-715   ConnectivityService     system_server                        D  Got NetworkProvider Messenger for Ethernet
2025-07-16 10:12:04.515   609-609   IpConfigStore           system_server                        E  Error opening configuration file: java.io.FileNotFoundException: /data/misc/ethernet/ipconfig.txt: open failed: ENOENT (No such file or directory)
2025-07-16 10:12:04.515   609-753   EthernetTracker         system_server                        I  maybeTrackInterface: eth1
2025-07-16 10:12:04.573   609-624   EthernetTracker         system_server                        I  interfaceLinkStateChanged, iface: eth1, up: false
2025-07-16 10:12:04.574   609-753   EthernetTracker         system_server                        D  Tracking interface in client mode: eth1
2025-07-16 10:12:04.574   609-753   EthernetNetworkFactory  system_server                        D  addInterface, iface: eth1, capabilities: [ Transports: ETHERNET Capabilities: NOT_METERED&INTERNET&NOT_RESTRICTED&TRUSTED&NOT_VPN&NOT_ROAMING&NOT_CONGESTED&NOT_SUSPENDED&NOT_VCN_MANAGED LinkUpBandwidth>=100000Kbps LinkDnBandwidth>=100000Kbps]
2025-07-16 10:12:04.574   609-753   EthernetNetworkFactory  system_server                        D  reconnecting Etherent
2025-07-16 10:12:04.574   609-753   EthernetNetworkFactory  system_server                        D  Starting Ethernet IpClient(eth1)
2025-07-16 10:12:04.603   609-609   SystemServerTiming      system_server                        D  OnBootPhase_520_com.android.server.ethernet.EthernetService
2025-07-16 10:12:04.825   609-609   SystemServerTiming      system_server                        D  OnBootPhase_550_com.android.server.ethernet.EthernetService
2025-07-16 10:12:04.926   609-609   SystemServerTiming      system_server                        D  OnBootPhase_600_com.android.server.ethernet.EthernetService
2025-07-16 10:12:04.956   609-609   SystemServerTiming      system_server                        D  ssm.onStartUser-0_com.android.server.ethernet.EthernetService
2025-07-16 10:12:05.790   609-753   EthernetNetworkFactory  system_server                        D  updateCapabilityFilter: [ Transports: ETHERNET Capabilities: NOT_METERED&INTERNET&NOT_RESTRICTED&TRUSTED&NOT_VPN&NOT_ROAMING&NOT_CONGESTED&NOT_SUSPENDED&NOT_VCN_MANAGED]
2025-07-16 10:12:05.790   609-753   EthernetNe...FactoryExt system_server                        E  get list of interfaces lo
2025-07-16 10:12:07.259   408-408   <no-tag>                netd                                 E  RTL8211F Gigabit Ethernet stmmac-1:01: 2ns TX delay was already disabled (by pin-strapping RXD1 or bootloader configuration)
2025-07-16 10:12:07.260   408-408   <no-tag>                netd                                 E  RTL8211F Gigabit Ethernet stmmac-1:01: Disabling 2ns RX delay (and changing the value from pin-strapping RXD0 or the bootloader)
2025-07-16 10:12:07.290   408-408   <no-tag>                netd                                 I  rk_gmac-dwmac fe1c0000.ethernet eth0: PHY [stmmac-1:01] driver [RTL8211F Gigabit Ethernet] (irq=POLL)
2025-07-16 10:12:07.293   408-408   <no-tag>                netd                                 I  rk_gmac-dwmac fe1c0000.ethernet eth0: No Safety Features support found
2025-07-16 10:12:07.293   408-408   <no-tag>                netd                                 I  rk_gmac-dwmac fe1c0000.ethernet eth0: IEEE 1588-2008 Advanced Timestamp supported
2025-07-16 10:12:07.293   408-408   <no-tag>                netd                                 I  rk_gmac-dwmac fe1c0000.ethernet eth0: registered PTP clock
2025-07-16 10:12:07.294   408-408   <no-tag>                netd                                 I  rk_gmac-dwmac fe1c0000.ethernet eth0: configuring for phy/rgmii link mode
2025-07-16 10:12:05.854   609-624   EthernetTracker         system_server                        I  interfaceLinkStateChanged, iface: eth0, up: false
2025-07-16 10:12:05.854   609-624   EthernetTracker         system_server                        I  interfaceLinkStateChanged, iface: eth0, up: false
2025-07-16 10:12:05.854   609-753   EthernetNetworkFactory  system_server                        D  updateInterfaceLinkState, iface: eth1, up: false
2025-07-16 10:12:05.854   609-753   EthernetNe...FactoryExt system_server                        D  interfaceLinkStateChanged: iface = eth1, mIface = eth0,up:false,mLinkUp:false
2025-07-16 10:12:05.854   609-753   EthernetNe...FactoryExt system_server                        D  interfaceLinkStateChanged: iface = eth0, mIface = eth0,up:false,mLinkUp:false
2025-07-16 10:12:05.854   609-753   EthernetNe...FactoryExt system_server                        D  interfaceLinkStateChanged: iface = eth0, mIface = eth0,up:false,mLinkUp:false

# å¤–ç½‘æ¥å…¥
2025-07-16 10:12:08.854   609-1201  EthernetTracker         system_server                        D  eth1 isEthernetInterfaceActive = true
2025-07-16 10:12:15.723   609-624   EthernetTracker         system_server                        I  interfaceLinkStateChanged, iface: eth1, up: true
2025-07-16 10:12:15.724   609-753   EthernetNetworkFactory  system_server                        D  updateInterfaceLinkState, iface: eth1, up: true
2025-07-16 10:12:15.793   609-753   EthernetNetworkFactory  system_server                        D  Starting Ethernet IpClient(eth1)
2025-07-16 10:12:15.794   609-753   EthernetNe...FactoryExt system_server                        D  interfaceLinkStateChanged: iface = eth1, mIface = eth0,up:true,mLinkUp:false

2025-07-16 10:12:16.318   609-753   ConnectivityService     system_server                        D  registerNetworkAgent NetworkAgentInfo{network{100}  handle{432902426637}  ni{Ethernet CONNECTING extra: 3a:97:4c:27:bb:ee} Score(70 ; KeepConnected : 0 ; Policies : IS_UNMETERED)   lp{{InterfaceName: eth1 LinkAddresses: [ fe80::d3:28:27a5:9920/64,192.168.1.183/24 ] DnsAddresses: [ /192.168.1.1 ] Domains: null MTU: 0 ServerAddress: /192.168.1.1 TcpBufferSizes: 524288,1048576,3145728,524288,1048576,2097152 Routes: [ fe80::/64 -> :: eth1 mtu 0,192.168.1.0/24 -> 0.0.0.0 eth1 mtu 0,0.0.0.0/0 -> 192.168.1.1 eth1 mtu 0 ]}}  nc{[ Transports: ETHERNET Capabilities: NOT_METERED&INTERNET&NOT_RESTRICTED&TRUSTED&NOT_VPN&NOT_ROAMING&FOREGROUND&NOT_CONGESTED&NOT_SUSPENDED&NOT_VCN_MANAGED LinkUpBandwidth>=100000Kbps LinkDnBandwidth>=100000Kbps]}}

2025-07-16 10:12:16.322   609-715   ConnectivityService     system_server                        D  [100 ETHERNET] EVENT_NETWORK_INFO_CHANGED, going from CONNECTING to CONNECTING
2025-07-16 10:12:16.322   609-715   ConnectivityService     system_server                        D  [100 ETHERNET] EVENT_NETWORK_INFO_CHANGED, going from CONNECTING to CONNECTED
2025-07-16 10:12:16.383   609-715   ConnectivityService     system_server                        D  Switching to new default network for: uid/pid:1000/609 activeRequest: 1 callbackRequest: 1 [NetworkRequest [ REQUEST id=1, [ Capabilities: INTERNET&NOT_RESTRICTED&TRUSTED&NOT_VPN&NOT_VCN_MANAGED RequestorUid: 1000 RequestorPkg: android] ]] callback flags: 1 priority: 2147483647 using NetworkAgentInfo{network{100}  handle{432902426637}  ni{Ethernet CONNECTED extra: 3a:97:4c:27:bb:ee} Score(70 ; KeepConnected : 0 ; Policies : IS_UNMETERED)   lp{{InterfaceName: eth1 LinkAddresses: [ fe80::d3:28:27a5:9920/64,192.168.1.183/24 ] DnsAddresses: [ /192.168.1.1 ] Domains: null MTU: 0 ServerAddress: /192.168.1.1 TcpBufferSizes: 524288,1048576,3145728,524288,1048576,2097152 Routes: [ fe80::/64 -> :: eth1 mtu 0,192.168.1.0/24 -> 0.0.0.0 eth1 mtu 0,0.0.0.0/0 -> 192.168.1.1 eth1 mtu 0 ]}}  nc{[ Transports: ETHERNET Capabilities: NOT_METERED&INTERNET&NOT_RESTRICTED&TRUSTED&NOT_VPN&NOT_ROAMING&FOREGROUND&NOT_CONGESTED&NOT_SUSPENDED&NOT_VCN_MANAGED LinkUpBandwidth>=100000Kbps LinkDnBandwidth>=100000Kbps]}}
2025-07-16 10:12:16.409   609-715   ConnectivityService     system_server                        D  Sending CONNECTED broadcast for type 9 [100 ETHERNET] isDefaultNetwork=true
2025-07-16 10:12:16.415   609-715   ConnectivityService     system_server                        D  [100 ETHERNET] validation passed

# å†…ç½‘æ¥å…¥
2025-07-16 10:22:33.060   609-624   EthernetTracker         system_server                        I  interfaceLinkStateChanged, iface: eth0, up: true
2025-07-16 10:22:33.060   609-753   EthernetNe...FactoryExt system_server                        D  interfaceLinkStateChanged: iface = eth0, mIface = eth0,up:true,mLinkUp:false
2025-07-16 10:22:34.526   218-218   <no-tag>                kworker/3                            I  rk_gmac-dwmac fe1c0000.ethernet eth0: Link is Up - 100Mbps/Full - flow control off
2025-07-16 10:22:34.061   609-2127  EthernetNe...FactoryExt system_server                        D  IpClient.startProvisioning
2025-07-16 10:22:34.062   609-2127  EthernetNe...FactoryExt system_server                        D  startDhcp success for eth0
2025-07-16 10:22:34.068   609-2128  EthernetNe...FactoryExt system_server                        D  onLinkPropertiesChange

```

#### SystemServer.java

./java/com/android/server/SystemServer.java

```java

    private void startOtherServices(@NonNull TimingsTraceAndSlog t) {

            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) ||
                    mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) {
                t.traceBegin("StartEthernet");
                mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
                t.traceEnd();
            }

    }

```

#### EthernetService.java

./opt/net/ethernet/java/com/android/server/ethernet/EthernetService.java


```java

public final class EthernetService extends SystemService {

    private static final String TAG = "EthernetService";
    final EthernetServiceImpl mImpl;

    public EthernetService(Context context) {
        super(context);
        mImpl = new EthernetServiceImpl(context);
    }

    @Override
    public void onStart() {
        Log.i(TAG, "Registering service " + Context.ETHERNET_SERVICE);
        publishBinderService(Context.ETHERNET_SERVICE, mImpl);
    }

    @Override
    public void onBootPhase(int phase) {
        if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
            mImpl.start();
        }
    }
}

```

#### EthernetServiceImpl.java

./opt/net/ethernet/java/com/android/server/ethernet/EthernetServiceImpl.java

```java


public class EthernetServiceImpl extends IEthernetManager.Stub {

    public void start() {
        Log.i(TAG, "Starting Ethernet service");

        HandlerThread handlerThread = new HandlerThread("EthernetServiceThread");
        handlerThread.start();
        mHandler = new Handler(handlerThread.getLooper());

        mTracker = new EthernetTracker(mContext, mHandler);
        mTracker.start();

        mStarted.set(true);
    }

}

```

#### EthernetTracker.java

è´Ÿè´£å…¨å±€è·Ÿè¸ªä»¥å¤ªç½‘æ¥å£ï¼ˆå¦‚ eth0/eth1ï¼‰çŠ¶æ€å˜åŒ–ï¼Œå¹¶åè°ƒé…ç½®ï¼ˆå¦‚ DHCP/é™æ€ IPï¼‰ã€é€šçŸ¥ç³»ç»Ÿè¿æ¥çŠ¶æ€ï¼ŒåŒæ—¶ç®¡ç† EthernetNetworkFactory

./opt/net/ethernet/java/com/android/server/ethernet/EthernetTracker.java

```java

final class EthernetTracker {


    /**
     * Interface names we track. This is a product-dependent regular expression, plus,
     * if setIncludeTestInterfaces is true, any test interfaces.
     */
    private String mIfaceMatch;

    private final Context mContext;
    private final INetworkManagementService mNMService;
    private final INetd mNetd;
    private final Handler mHandler;
    private final EthernetNetworkFactory mFactory;
    private final EthernetConfigStore mConfigStore;
    private final WifiSleepController mWifiSleepController;

    //lixiaogang add
    private EthernetNetworkFactoryExt mEthernetNetworkFactoryExt;

    EthernetTracker(Context context, Handler handler) {
        mContext = context;
        mHandler = handler;

        // The services we use.
        IBinder b = ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
        mNMService = INetworkManagementService.Stub.asInterface(b);
        mNetd = Objects.requireNonNull(NetdService.getInstance(), "could not get netd instance");

        // Interface match regex.
        updateIfaceMatchRegexp();


        mConfigStore = new EthernetConfigStore();

        NetworkCapabilities nc = createNetworkCapabilities(true /* clear default capabilities */);
        mFactory = new EthernetNetworkFactory(handler, context, nc);

        // å°†è¿™ä¸ªç½‘ç»œå·¥å‚ï¼ˆNetworkFactoryï¼‰æ³¨å†Œåˆ°ç³»ç»Ÿçš„ ConnectivityServiceï¼Œå‘ŠçŸ¥ç³»ç»Ÿè¯¥å·¥å‚èƒ½å¤Ÿæä¾›æŸç±»ç½‘ç»œæœåŠ¡ï¼ˆå¦‚ä»¥å¤ªç½‘ï¼‰ï¼Œä»è€Œèƒ½å¤Ÿæ¥æ”¶ç½‘ç»œè¯·æ±‚å¹¶ç®¡ç†ç½‘ç»œè¿æ¥ã€‚
        mFactory.register();
        mWifiSleepController = new WifiSleepController(mContext);

        //lixiaogang add
        mEthernetNetworkFactoryExt = new EthernetNetworkFactoryExt();
    }


    void start() {
        mConfigStore.read();

        // Default interface is just the first one we want to track.
        mIpConfigForDefaultInterface = mConfigStore.getIpConfigurationForDefaultInterface();
        final ArrayMap<String, IpConfiguration> configs = mConfigStore.getIpConfigurations();

        // å°†æ‰€æœ‰æ¥å£é…ç½®å¤åˆ¶åˆ° mIpConfigurationsï¼ˆå½“å‰è¿è¡Œæ—¶ç¼“å­˜çš„é…ç½®é›†åˆï¼‰ï¼Œä»¥ä¾¿éšæ—¶è®¿é—®å’Œç®¡ç†
        for (int i = 0; i < configs.size(); i++) {
            mIpConfigurations.put(configs.keyAt(i), configs.valueAt(i));
        }

        // å‘ç½‘ç»œç®¡ç†æœåŠ¡ï¼ˆNetworkManagementServiceï¼‰æ³¨å†Œä¸€ä¸ªè§‚å¯Ÿè€…ï¼Œç”¨äºç›‘å¬ç½‘å¡æ¥å£çš„å¢åˆ ã€çŠ¶æ€å˜åŒ–ï¼ˆup/down/linkï¼‰äº‹ä»¶ã€‚
        try {
            mNMService.registerObserver(new InterfaceObserver());
        } catch (RemoteException e) {
            Log.e(TAG, "Could not register InterfaceObserver " + e);
        }

        // é€šè¿‡ Handler å¼‚æ­¥æ‰§è¡Œ trackAvailableInterfaces() æ–¹æ³•ï¼Œå¼€å§‹æ‰«æå’Œè¿½è¸ªå½“å‰ç³»ç»Ÿå·²æœ‰çš„ä»¥å¤ªç½‘æ¥å£ã€‚
        mHandler.post(this::trackAvailableInterfaces);
    }

    // è·å–å¤–ç½‘æ¥å£
    private void updateIfaceMatchRegexp() {
        // modify lixiaogang start
        // final String match = mContext.getResources().getString(
        //         com.android.internal.R.string.config_ethernet_iface_regex);
        // mIfaceMatch = mIncludeTestInterfaces
        //         ? "(" + match + "|" + TEST_IFACE_REGEXP + ")"
        //         : match;
        mIfaceMatch = SystemProperties.get("ro.net.eth_primary", "eth0");//"eth1";
        Log.d(TAG, "Interface match regexp set to '" + mIfaceMatch + "'");
        // modify lixiaogang end
    }

    private class InterfaceObserver extends BaseNetworkObserver {

        @Override
        public void interfaceLinkStateChanged(String iface, boolean up) {
            if (DBG) {
                Log.i(TAG, "interfaceLinkStateChanged, iface: " + iface + ", up: " + up);
            }

            if(isEthernetInterfaceActive())
                mHandler.post(() -> updateInterfaceState(iface, up));
            else{
                if (iface.matches(mIfaceMatch)){
                       mHandler.post(() -> updateInterfaceState(iface, false));
                       Settings.System.putInt(mContext.getContentResolver(),Settings.System.ETHERNET_ON,0);
            }}

            mHandler.post(() -> mEthernetNetworkFactoryExt.interfaceLinkStateChanged(iface, up));
        }

        @Override
        public void interfaceAdded(String iface) {
            mHandler.post(() -> maybeTrackInterface(iface));
            mHandler.post(() -> mEthernetNetworkFactoryExt.interfaceAdded(iface));
        }

        @Override
        public void interfaceRemoved(String iface) {
            mHandler.post(() -> stopTrackingInterface(iface));
            mHandler.post(() -> mEthernetNetworkFactoryExt.interfaceRemoved(iface));
        }
    }

    private boolean maybeTrackInterface(String iface) {
        if (!iface.matches(mIfaceMatch)) {
            return false;
        }

        // If we don't already track this interface, and if this interface matches
        // our regex, start tracking it.
        if (mFactory.hasInterface(iface) || iface.equals(mDefaultInterface)) {
            if (DBG) Log.w(TAG, "Ignoring already-tracked interface " + iface);
            return false;
        }
        if (DBG) Log.i(TAG, "maybeTrackInterface: " + iface);

        // TODO: avoid making an interface default if it has configured NetworkCapabilities.
        if (mDefaultInterface == null) {
            mDefaultInterface = iface;
        }

        if (mIpConfigForDefaultInterface != null) {
            updateIpConfiguration(iface, mIpConfigForDefaultInterface);
            mIpConfigForDefaultInterface = null;
        }

        addInterface(iface);
        mEthernetNetworkFactoryExt.start(mContext, mNMService);
        return true;
    }

    private void trackAvailableInterfaces() {
        try {
            final String[] ifaces = mNMService.listInterfaces();
            for (String iface : ifaces) {
                if (maybeTrackInterface(iface)) {
                    String mIfaceTmp = iface;
                    new Thread(new Runnable() {
                        public void run() {
                            // carrier is always 1 when kernel boot up no matter RJ45 plugin or not,
                            // sleep a little time to wait kernel's correct carrier status
                            try {
                                Thread.sleep(3000);
                            } catch (InterruptedException ignore) {
                            }
                            Log.d(TAG, mIfaceTmp + " isEthernetInterfaceActive = " + isEthernetInterfaceActive());
                            if (!isEthernetInterfaceActive()) {
                                updateInterfaceState(mIfaceTmp, false);
                            }
                        }
                    }).start();
                    break;
                }

            }
        } catch (RemoteException | IllegalStateException e) {
            Log.e(TAG, "Could not get list of interfaces " + e);
        }
    }

}

```

#### EthernetConfigStore.java

ç”¨äºæŒä¹…åŒ–ä»¥å¤ªç½‘é…ç½®ä¿¡æ¯çš„ç»„ä»¶ï¼Œå…¶ä¸»è¦åŠŸèƒ½æ˜¯ï¼šå°†ä»¥å¤ªç½‘æ¥å£ï¼ˆå¦‚ eth0ã€eth1ï¼‰çš„ IP é…ç½®ï¼ˆå¦‚é™æ€ IPã€DNSã€ä»£ç†ç­‰ï¼‰å­˜å‚¨åˆ° XML æ–‡ä»¶ä¸­ï¼Œå¹¶åœ¨ç³»ç»Ÿå¯åŠ¨æ—¶æ¢å¤è¿™äº›é…ç½®ã€‚

```java

/**
 * This class provides an API to store and manage Ethernet network configuration.
 */
public class EthernetConfigStore {
    private static final String ipConfigFile = Environment.getDataDirectory() +
            "/misc/ethernet/ipconfig.txt";

    private IpConfigStore mStore = new IpConfigStore();
    private ArrayMap<String, IpConfiguration> mIpConfigurations;
    private IpConfiguration mIpConfigurationForDefaultInterface;
    private final Object mSync = new Object();

    public EthernetConfigStore() {
        mIpConfigurations = new ArrayMap<>(0);
    }

    public void read() {
        synchronized (mSync) {
            ArrayMap<String, IpConfiguration> configs =
                    IpConfigStore.readIpConfigurations(ipConfigFile);

            // This configuration may exist in old file versions when there was only a single active
            // Ethernet interface.
            if (configs.containsKey("0")) {
                mIpConfigurationForDefaultInterface = configs.remove("0");
            }

            mIpConfigurations = configs;
        }
    }

    public void write(String iface, IpConfiguration config) {
        boolean modified;

        synchronized (mSync) {
            if (config == null) {
                modified = mIpConfigurations.remove(iface) != null;
            } else {
                IpConfiguration oldConfig = mIpConfigurations.put(iface, config);
                modified = !config.equals(oldConfig);
            }

            if (modified) {
                mStore.writeIpConfigurations(ipConfigFile, mIpConfigurations);
            }
        }
    }

    public ArrayMap<String, IpConfiguration> getIpConfigurations() {
        synchronized (mSync) {
            return new ArrayMap<>(mIpConfigurations);
        }
    }

    @Nullable
    public IpConfiguration getIpConfigurationForDefaultInterface() {
        synchronized (mSync) {
            return mIpConfigurationForDefaultInterface == null
                    ? null : new IpConfiguration(mIpConfigurationForDefaultInterface);
        }
    }
}

```

#### EthernetNetworkFactory.java

EthernetNetworkFactory è´Ÿè´£ä»£è¡¨â€œä»¥å¤ªç½‘â€å‘ Android ç³»ç»Ÿæ³¨å†Œå¹¶ç»´æŠ¤ç½‘ç»œè¿æ¥ï¼Œåˆ›å»º NetworkAgentï¼Œå®ç°ä¸ ConnectivityService çš„åŒå‘è¿æ¥ä¸çŠ¶æ€æ›´æ–°ã€‚

```java

public class EthernetNetworkFactory extends NetworkFactory {

    private final static int NETWORK_SCORE = 70;
    private static final String NETWORK_TYPE = "Ethernet";
    
    public EthernetNetworkFactory(Handler handler, Context context, NetworkCapabilities filter) {
        super(handler.getLooper(), context, NETWORK_TYPE, filter);

        mHandler = handler;
        mContext = context;

        setScoreFilter(NETWORK_SCORE);
        mEthernetManager = (EthernetManager) context.getSystemService(Context.ETHERNET_SERVICE);
    }

}


public class NetworkFactory {

    public NetworkFactory(Looper looper, Context context, String logTag,
            @Nullable final NetworkCapabilities filter) {
        LOG_TAG = logTag;
        if (isAtLeastS()) {
            mImpl = new NetworkFactoryImpl(this, looper, context, filter);
        } else {
            mImpl = new NetworkFactoryLegacyImpl(this, looper, context, filter);
        }
    }

    // å°†è¿™ä¸ªç½‘ç»œå·¥å‚ï¼ˆNetworkFactoryï¼‰æ³¨å†Œåˆ°ç³»ç»Ÿçš„ ConnectivityServiceï¼Œå‘ŠçŸ¥ç³»ç»Ÿè¯¥å·¥å‚èƒ½å¤Ÿæä¾›æŸç±»ç½‘ç»œæœåŠ¡ï¼ˆå¦‚ä»¥å¤ªç½‘ï¼‰ï¼Œä»è€Œèƒ½å¤Ÿæ¥æ”¶ç½‘ç»œè¯·æ±‚å¹¶ç®¡ç†ç½‘ç»œè¿æ¥ã€‚
    public void register() {
        mImpl.register(LOG_TAG);
    }

}


class NetworkFactoryImpl extends NetworkFactoryLegacyImpl {

    private void register(final String logTag, final boolean listenToAllRequests) {
        if (mProvider != null) {
            throw new IllegalStateException("A NetworkFactory must only be registered once");
        }
        if (DBG) mParent.log("Registering NetworkFactory");

        mProvider = new NetworkProvider(mContext, NetworkFactoryImpl.this.getLooper(), logTag) {
            @Override
            public void onNetworkRequested(@NonNull NetworkRequest request, int score,
                    int servingProviderId) {
                handleAddRequest(request);
            }

            @Override
            public void onNetworkRequestWithdrawn(@NonNull NetworkRequest request) {
                handleRemoveRequest(request);
            }
        };

        ((ConnectivityManager) mContext.getSystemService(
                Context.CONNECTIVITY_SERVICE)).registerNetworkProvider(mProvider);

        // The mScore and mCapabilityFilter members can only be accessed on the handler thread.
        // TODO : offer a separate API to listen to all requests instead
        if (listenToAllRequests) {
            sendMessage(obtainMessage(CMD_LISTEN_TO_ALL_REQUESTS));
        } else {
            sendMessage(obtainMessage(CMD_OFFER_NETWORK));
        }
    }

}

```

## å·¥ä½œæµç¨‹å›¾

```mermid

sequenceDiagram
    autonumber
    participant PHY/Kernel as [ğŸŒ ç‰©ç†ç½‘å£/Kernel]
    participant Netd as [ğŸ§© Netd]
    participant EthernetTracker as [ğŸ§  EthernetTracker]
    participant ConfigStore as [ğŸ’¾ EthernetConfigStore]
    participant NetFactory as [ğŸ—ï¸ EthernetNetworkFactory]
    participant IpClient as [ğŸ“¡ IpClient]
    participant ConnSvc as [ğŸ§  ConnectivityService]

    PHY/Kernel->>Netd: 1. eth0 æ’å…¥ (link up)
    Netd->>EthernetTracker: 2. interfaceAdded("eth0")

    EthernetTracker->>ConfigStore: 3. è¯»å– eth0 é…ç½®
    ConfigStore-->>EthernetTracker: è¿”å› IpConfiguration

    EthernetTracker->>NetFactory: 4. maybeStartNetwork("eth0")
    NetFactory->>IpClient: 5. å¯åŠ¨ DHCP / é™æ€ IP é…ç½®
    IpClient-->>NetFactory: 6. Provisioning æˆåŠŸ (onProvisioningSuccess)

    NetFactory->>ConnSvc: 7. åˆ›å»º NetworkAgent
    ConnSvc-->>NetFactory: æ³¨å†Œå®Œæˆ

    ConnSvc->>System: 8. è®¾ç½® eth0 ä¸ºé»˜è®¤ç½‘ç»œï¼ˆå¦‚ä¼˜å…ˆçº§æœ€é«˜ï¼‰

    Note over EthernetTracker,NetFactory: åç»­å¦‚æ¥å£ downï¼Œå°†è‡ªåŠ¨è§¦å‘ maybeStopNetwork()

```

| ç¼–å· | æ­¥éª¤è§£é‡Š |
|------|----------|
| 1    | ç”¨æˆ·æ’ä¸Šç½‘çº¿æˆ–æ’å…¥ USB ç½‘å¡ï¼Œé©±åŠ¨åˆ›å»º `eth0` æ¥å£ |
| 2    | `Netd` é€šè¿‡ `INetworkManagementService` é€šçŸ¥ä¸Šå±‚æœ‰æ–°æ¥å£ |
| 3    | `EthernetTracker` æŸ¥è¯¢è¯¥æ¥å£çš„é…ç½®ï¼ˆé™æ€ IP / DHCPï¼‰ |
| 4    | å¦‚æœæ¥å£ä¸º upï¼Œè°ƒç”¨ `EthernetNetworkFactory` å»ºç«‹è¿æ¥ |
| 5    | `IpClient` æ‰§è¡Œå®é™… IP åˆ†é…ï¼ˆDHCPï¼‰æˆ–è®¾ç½®é™æ€ IP |
| 6    | IP æˆåŠŸé…ç½®åï¼Œé€šçŸ¥è¿æ¥å¯ç”¨ |
| 7    | `EthernetNetworkFactory` åˆ›å»º `NetworkAgent`ï¼Œæ³¨å†Œåˆ° `ConnectivityService` |
| 8    | ç³»ç»Ÿæ ¹æ®ä¼˜å…ˆçº§å°† eth0 è®¾ç½®ä¸ºé»˜è®¤ç½‘ç»œï¼Œå¹¶å‘ apps å¹¿æ’­è¿æ¥å¯ç”¨ |






















